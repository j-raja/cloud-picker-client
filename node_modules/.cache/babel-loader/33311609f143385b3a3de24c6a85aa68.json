{"ast":null,"code":"// Lets use Lappeenranta as default location in case user denies geolocation request\nlet userLatitude = 61;\nlet userLongitude = 28; // Calculate the distance between the client and the cloud and sort the list\n\nexport async function sortByDistance(clouds) {\n  return getPosition().then(pos => {\n    return sortList(clouds, pos);\n  }).catch(error => {\n    console.log(error);\n    return sortList(clouds, null);\n  });\n}\n\nfunction sortList(clouds, pos) {\n  if (pos) {\n    userLatitude = pos.coords.latitude;\n    userLongitude = pos.coords.longitude;\n  }\n\n  const calculatedList = [];\n  clouds.forEach(element => {\n    let distance = 0;\n    distance = getDistanceFromLatLonInKm(element.latitude, element.longitude, userLatitude, userLongitude);\n    element.distance = distance;\n    calculatedList.push(element);\n  });\n  return calculatedList.sort((_ref, _ref2) => {\n    let {\n      distance: a\n    } = _ref;\n    let {\n      distance: b\n    } = _ref2;\n    return a - b;\n  });\n} // Get users geolocation\n\n\nfunction getPosition() {\n  return new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject));\n} // Calculate the distance in Km just for flavor using Haversine formula\n// This is copied from https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula\n\n\nfunction getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {\n  var R = 6371; // Radius of the earth in km\n\n  var dLat = deg2rad(lat2 - lat1); // deg2rad below\n\n  var dLon = deg2rad(lon2 - lon1);\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c; // Distance in km\n\n  return Math.round(d);\n}\n\nfunction deg2rad(deg) {\n  return deg * (Math.PI / 180);\n}","map":{"version":3,"sources":["D:/Projects/cloud-picker/cloud-picker-client/cloud-picker-client/src/utils/utils.ts"],"names":["userLatitude","userLongitude","sortByDistance","clouds","getPosition","then","pos","sortList","catch","error","console","log","coords","latitude","longitude","calculatedList","forEach","element","distance","getDistanceFromLatLonInKm","push","sort","a","b","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","lat1","lon1","lat2","lon2","R","dLat","deg2rad","dLon","Math","sin","cos","c","atan2","sqrt","d","round","deg","PI"],"mappings":"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","sourcesContent":["import { Cloud } from \"../interface\";\r\n\r\n// Lets use Lappeenranta as default location in case user denies geolocation request\r\nlet userLatitude = 61;\r\nlet userLongitude = 28;\r\n\r\n// Calculate the distance between the client and the cloud and sort the list\r\nexport async function sortByDistance(clouds: Cloud[]): Promise<Cloud[]> {\r\n    return getPosition().then(pos => {\r\n        return sortList(clouds, pos);\r\n    }).catch((error) => {\r\n        console.log(error);\r\n        return sortList(clouds, null);\r\n    })\r\n}\r\n\r\nfunction sortList(clouds: Cloud[], pos: GeolocationPosition | null) {\r\n    if (pos) {\r\n        userLatitude = pos.coords.latitude;\r\n        userLongitude = pos.coords.longitude;\r\n    }\r\n    const calculatedList: Cloud[] = [];\r\n    clouds.forEach(element => {\r\n        let distance = 0;\r\n        distance = getDistanceFromLatLonInKm(element.latitude, element.longitude, userLatitude, userLongitude);\r\n        element.distance = distance;\r\n        calculatedList.push(element);\r\n    });\r\n    return calculatedList.sort(({ distance: a }, { distance: b }) => a - b);\r\n}\r\n\r\n// Get users geolocation\r\nfunction getPosition(): Promise<GeolocationPosition> {\r\n    return new Promise((resolve, reject) =>\r\n        navigator.geolocation.getCurrentPosition(resolve, reject)\r\n    );\r\n}\r\n\r\n// Calculate the distance in Km just for flavor using Haversine formula\r\n// This is copied from https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula\r\nfunction getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number) {\r\n    var R = 6371; // Radius of the earth in km\r\n    var dLat = deg2rad(lat2 - lat1);  // deg2rad below\r\n    var dLon = deg2rad(lon2 - lon1);\r\n    var a =\r\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *\r\n        Math.sin(dLon / 2) * Math.sin(dLon / 2)\r\n        ;\r\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    var d = R * c; // Distance in km\r\n    return Math.round(d);\r\n}\r\n\r\nfunction deg2rad(deg: number) {\r\n    return deg * (Math.PI / 180)\r\n}"]},"metadata":{},"sourceType":"module"}